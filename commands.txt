### app ###
npm i
npm start

### docker ###
minikube start
eval $(minikube docker-env)
docker build -t training:v1 .

### secret ###
kubectl create -f ./secret.yaml
kubectl get secrets

### deployment ###
kubectl create -f ./deployment.yaml
kubectl get deployments
kubectl get pods

### service ###
kubectl create -f ./service.yaml
kubectl get services
minikube service training-service

### sidecar-logging-agent ###
kubectl get pods
pod=$(kubectl get pods  --show-all --selector=app=training --output=jsonpath={.items..metadata.name})
kubectl logs $pod logging-agent

### hpa ###
minikube addons enable heapster
minikube addons list
# minikube addons open heapster
kubectl create -f ./hpa.yaml
# wait a couple of minutes until you see TARGETS 0%/50% on the next command
kubectl get hpa
kubectl run -i --tty load-generator --image=busybox /bin/sh
  while true; do wget -q -O- http://192.168.99.100:30001/; done
# wait a couple of minutes
kubectl get hpa

### jobs ###
kubectl create -f ./job.yaml
kubectl get jobs
job=$(kubectl get pods  --show-all --selector=job-name=training-job --output=jsonpath={.items..metadata.name})
kubectl logs $job job-1
kubectl logs $job job-2
kubectl logs $job job-done
kubectl get jobs # SUCCESSFUL -> pod status: Succeeded

### daemonset ###
kubectl label node minikube app=logging-node --overwrite
kubectl create -f ./daemon.yaml
kubectl get ds

### parallel jobs with queue ###
kubectl create -f ./redis-pod.yaml
kubectl create -f ./redis-service.yaml
kubectl run -i --tty temp --image redis --command "/bin/sh"
  redis-cli -h redis
  # create the queue here by pushing task keys to 'job' list
  rpush job "task1"
  rpush job "task2"
  rpush job "task3"
# build docker file for redis-worker.js (node ./redis-worker.js): job-worker-training:v1
kubectl create -f ./job-parallel-queue.yaml
jobsArray=($(echo $(kubectl get pods  --show-all --selector=job-name=training-job-parallel --output=jsonpath={.items..metadata.name}) | tr ' ' '\n'))
kubectl logs ${jobsArray[1]}
kubectl logs ${jobsArray[2]}0

### cron job ###
kubectl create -f ./job-cron.yaml
kubectl get cronjob training-job-cron
# this will create a cronjob which is going to create a job in every minute
# if you want to see the logs of a job: get jobs, select one from the cron, find its pod and log it
# kubectl get jobs
# pod=$(kubectl get pods -a --selector=job-name=training-job-cron-1516207920 --output=jsonpath={.items..metadata.name})
# kubectl logs $pod
kubectl delete cronjob hello

### configmap ###
kubectl create -f ./configmap-production.yaml
kubectl create -f ./configmap-staging.yaml
kubectl create -f ./configmap-volumes.yaml
kubectl create -f ./deployment.yaml
kubectl get configmaps
pod=$(kubectl get pods  --show-all --selector=app=training --output=jsonpath={.items..metadata.name})
kubectl exec -it $pod -c training /bin/sh
  cat /etc/config/training.type
  echo $NODE_ENV

### statefulset ###
# terminal 1
kubectl get pods -w -l app=training-statefulset
# terminal 2
kubectl create -f ./statefulset.yaml
kubectl get statefulset training-statefulset
for i in 0 1; do kubectl exec training-statefulset-$i -- sh -c 'echo $(hostname) > /usr/share/nginx/html/index.html'; done
for i in 0 1; do kubectl exec -it training-statefulset-$i -- curl localhost; done
minikube service training-statefulset-service
kubectl delete statefulset training-statefulset
  # deletes statefulset and pods, use --cascade=false to keep pods
