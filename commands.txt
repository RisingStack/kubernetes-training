### app ###
npm i
npm start

### docker ###
minikube start
eval $(minikube docker-env)
docker build -t training:v1 .

### secret ###
kubectl create -f ./secret.yaml
kubectl get secrets

### deployment ###
kubectl create -f ./deployment.yaml
kubectl get deployments
kubectl get pods

### service ###
kubectl create -f ./service.yaml
kubectl get services
minikube service training-service

### sidecar-logging-agent ###
kubectl get pods
pod=$(kubectl get pods  --show-all --selector=app=training --output=jsonpath={.items..metadata.name})
kubectl logs $pod logging-agent

### hpa ###
minikube addons enable heapster
minikube addons list
# minikube addons open heapster
kubectl create -f ./hpa.yaml
# wait a couple of minutes until you see TARGETS 0%/50% on the next command
kubectl get hpa
kubectl run -i --tty load-generator --image=busybox /bin/sh
  while true; do wget -q -O- http://192.168.99.100:30001/; done
# wait a couple of minutes
kubectl get hpa

### jobs ###
kubectl create -f ./job.yaml
kubectl get jobs
job=$(kubectl get pods  --show-all --selector=job-name=training-job --output=jsonpath={.items..metadata.name})
kubectl logs $job job-1
kubectl logs $job job-2
kubectl logs $job job-done
kubectl get jobs # SUCCESSFUL -> pod status: Succeeded

### daemonset ###
kubectl label node minikube app=logging-node --overwrite
kubectl create -f ./daemon.yaml
kubectl get ds

### parallel jobs with queue ###
kubectl create -f ./redis-pod.yaml
kubectl create -f ./redis-service.yaml
kubectl run -i --tty temp --image redis --command "/bin/sh"
  redis-cli -h redis
  # create the queue here by pushing task keys to 'job' list
  rpush job "task1"
  rpush job "task2"
  rpush job "task3"
# build docker file for redis-worker.js (node ./redis-worker.js): job-worker-training:v1
kubectl create -f ./job-parallel-queue.yaml
jobsArray=($(echo $(kubectl get pods  --show-all --selector=job-name=training-job-parallel --output=jsonpath={.items..metadata.name}) | tr ' ' '\n'))
kubectl logs ${jobsArray[1]}
kubectl logs ${jobsArray[2]}0

### cron job ###
kubectl create -f ./job-cron.yaml
kubectl get cronjob training-job-cron
# this will create a cronjob which is going to create a job in every minute
# if you want to see the logs of a job: get jobs, select one from the cron, find its pod and log it
# kubectl get jobs
# pod=$(kubectl get pods -a --selector=job-name=training-job-cron-1516207920 --output=jsonpath={.items..metadata.name})
# kubectl logs $pod
kubectl delete cronjob hello

### configmap ###
kubectl create -f ./configmap-production.yaml
kubectl create -f ./configmap-staging.yaml
kubectl create -f ./configmap-volumes.yaml
kubectl create -f ./deployment.yaml
kubectl get configmaps
pod=$(kubectl get pods  --show-all --selector=app=training --output=jsonpath={.items..metadata.name})
kubectl exec -it $pod -c training /bin/sh
  cat /etc/config/training.type
  echo $NODE_ENV

### statefulset ###
# terminal 1
kubectl get pods -w -l app=training-statefulset
# terminal 2
kubectl create -f ./statefulset.yaml
kubectl get statefulset training-statefulset
for i in 0 1; do kubectl exec training-statefulset-$i -- sh -c 'echo $(hostname) > /usr/share/nginx/html/index.html'; done
for i in 0 1; do kubectl exec -it training-statefulset-$i -- curl localhost; done
minikube service training-statefulset-service
kubectl delete statefulset training-statefulset
  # deletes statefulset and pods, use --cascade=false to keep pods

### ingress ###
minikube addons enable ingress
minikube addons list
kubectl create -f ./service-ingress.yaml # only cluster can access it
kubectl create -f ./ingress.yaml
echo "$(minikube ip) risingstack.training.kubernetes.com" | sudo tee -a /etc/hosts
# visit risingstack.training.kubernetes.com

### helm ###
# OSX
  brew install kubernetes-helm
# LINUX
  curl https://raw.githubusercontent.com/kubernetes/helm/master/scripts/get > get_helm.sh
  chmod 700 get_helm.sh
  ./get_helm.sh
helm init
kubectl get pods --namespace kube-system
helm version
helm create training-chart
helm package training-chart
helm install training-chart --version 0.1.0
export POD_NAME=$(kubectl get pods --namespace default -l "app=training-chart,release=plucking-butterfly" -o jsonpath="{.items[0].metadata.name}")
kubectl port-forward $POD_NAME 8080:80
# http://127.0.0.1:8080

### istio ###
curl -L https://git.io/getLatestIstio | sh -
cd istio-0.4.0
# temporary istioctl export (if you are using zsh, edit .zshrc to inculde permanent export)
  export PATH=$PWD/bin:$PATH
kubectl apply -f install/kubernetes/istio.yaml
kubectl get svc -n istio-system
kubectl get pods -n istio-system
# deploy app
  kubectl create -f <(istioctl kube-inject -f <your-app-spec>.yaml)
